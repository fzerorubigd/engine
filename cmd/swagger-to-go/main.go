package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"

	"elbix.dev/engine/pkg/assert"
	"elbix.dev/engine/pkg/log"
	"go.uber.org/zap/buffer"
)

type swaggerFile struct {
	Swagger string `json:"swagger"`
	Info    struct {
		Title   string `json:"title"`
		Version string `json:"version"`
	} `json:"info"`
	Schemes     []string               `json:"schemes"`
	Consumes    []string               `json:"consumes"`
	Produces    []string               `json:"produces"`
	Paths       map[string]interface{} `json:"paths"`
	Definitions map[string]interface{} `json:"definitions"`
}

var (
	file = flag.String("file", os.Getenv("JSON_FILE"), "json file to load")
	pkg  = flag.String("pkg", os.Getenv("PACKAGE"), "target package name")
)

func main() {
	flag.Parse()

	fl, err := os.Open(*file)
	if err != nil {
		log.Fatal("Open file failed", log.Err(err))
	}

	var swag swaggerFile
	if err = json.NewDecoder(fl).Decode(&swag); err != nil {
		log.Fatal("Can not read valid swagger data")
	}

	out := &buffer.Buffer{}
	write(out, "// Code generated by swagger-to-go. DO NOT EDIT.")
	write(out, "package "+*pkg)
	write(out, `
import (
	"encoding/json"

	"elbix.dev/engine/pkg/assert"
	"elbix.dev/engine/pkg/grpcgw"
)

`)

	path, err := json.Marshal(swag.Paths)
	assert.Nil(err)
	write(out, fmt.Sprintf("const paths = %q", string(path)))

	def, err := json.Marshal(swag.Definitions)
	assert.Nil(err)
	write(out, fmt.Sprintf("const definitions = %q", string(def)))

	write(out, `
func init() {
	var (
		p = make(map[string]interface{})
		d = make(map[string]interface{})
	)

	assert.Nil(json.Unmarshal([]byte(paths), &p))
	assert.Nil(json.Unmarshal([]byte(definitions), &d))

	grpcgw.RegisterSwagger(p, d)
}
`)

	formatted, err := format.Source(out.Bytes())
	if err != nil {
		log.Fatal("Format go code failed", log.Err(err))
	}

	write(os.Stdout, string(formatted))

}

func write(w io.Writer, text string) {
	_, err := fmt.Fprintln(w, text)
	assert.Nil(err)
}
